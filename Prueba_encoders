#define EncoderPinA 4
#define EncoderPinB 13
#define EncoderPinAB 27
#define EncoderPinBB 14

#include "driver/gpio.h"

volatile long Encodervalue = 0;   // Contador para Motor A
volatile long EncodervalueB = 0;  // Contador para Motor B

// Declaración anticipada de las funciones
void updateEncoderA();
void updateEncoderB();

void setup() {
  Serial.begin(115200);
  
  // Configuración Motor A
  pinMode(EncoderPinA, INPUT_PULLUP);
  pinMode(EncoderPinB, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(EncoderPinA), updateEncoderA, CHANGE);
  
  // Configuración Motor B
  pinMode(EncoderPinAB, INPUT_PULLUP);
  pinMode(EncoderPinBB, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(EncoderPinAB), updateEncoderB, CHANGE);
}

void loop() {
  static unsigned long lastPrint = 0;
  
  if (millis() - lastPrint > 100) {
    lastPrint = millis();
    
    // Lectura segura de los contadores
    long motorA, motorB;
    noInterrupts();
    motorA = Encodervalue;
    motorB = EncodervalueB;
    interrupts();
    
    Serial.print("Motor A: ");
    Serial.print(motorA);
    Serial.print(" pulsos | Motor B: ");
    Serial.print(motorB);
    Serial.println(" pulsos");
  }
}

// Función de interrupción para Motor A
void updateEncoderA() {
  if (gpio_get_level((gpio_num_t)EncoderPinB) == 0) {
    Encodervalue = Encodervalue + 1;
  } else {
    Encodervalue = Encodervalue - 1;
  }
}

void updateEncoderB() {
  if (gpio_get_level((gpio_num_t)EncoderPinBB) == 0) {
    EncodervalueB = EncodervalueB + 1;
  } else {
    EncodervalueB = EncodervalueB - 1;
  }
}
